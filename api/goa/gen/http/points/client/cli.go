// Code generated by goa v3.8.2, DO NOT EDIT.
//
// Points HTTP client CLI support package
//
// Command:
// $ goa gen github.com/danapsimer/dvc-points-calculator/api/goa/design -o
// api/goa

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	points "github.com/danapsimer/dvc-points-calculator/api/goa/gen/points"
	goa "goa.design/goa/v3/pkg"
)

// BuildGetResortPayload builds the payload for the Points GetResort endpoint
// from CLI flags.
func BuildGetResortPayload(pointsGetResortResortCode string) (*points.GetResortPayload, error) {
	var err error
	var resortCode string
	{
		resortCode = pointsGetResortResortCode
		err = goa.MergeErrors(err, goa.ValidatePattern("resortCode", resortCode, "[a-z]{3}"))
		if err != nil {
			return nil, err
		}
	}
	v := &points.GetResortPayload{}
	v.ResortCode = resortCode

	return v, nil
}

// BuildPutResortPayload builds the payload for the Points PutResort endpoint
// from CLI flags.
func BuildPutResortPayload(pointsPutResortBody string, pointsPutResortResortCode string) (*points.PutResortPayload, error) {
	var err error
	var body PutResortRequestBody
	{
		err = json.Unmarshal([]byte(pointsPutResortBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"name\": \"Disney\\'s Saratoga Springs Resort \\u0026 Spa\"\n   }'")
		}
	}
	var resortCode string
	{
		resortCode = pointsPutResortResortCode
		err = goa.MergeErrors(err, goa.ValidatePattern("resortCode", resortCode, "[a-z]{3}"))
		if err != nil {
			return nil, err
		}
	}
	v := &points.PutResortPayload{
		Name: body.Name,
	}
	v.ResortCode = resortCode

	return v, nil
}

// BuildGetResortYearPayload builds the payload for the Points GetResortYear
// endpoint from CLI flags.
func BuildGetResortYearPayload(pointsGetResortYearResortCode string, pointsGetResortYearYear string) (*points.GetResortYearPayload, error) {
	var err error
	var resortCode string
	{
		resortCode = pointsGetResortYearResortCode
		err = goa.MergeErrors(err, goa.ValidatePattern("resortCode", resortCode, "[a-z]{3}"))
		if err != nil {
			return nil, err
		}
	}
	var year int
	{
		var v int64
		v, err = strconv.ParseInt(pointsGetResortYearYear, 10, strconv.IntSize)
		year = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for year, must be INT")
		}
		if year < 1990 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("year", year, 1990, true))
		}
		if year > 2100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("year", year, 2100, false))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &points.GetResortYearPayload{}
	v.ResortCode = resortCode
	v.Year = year

	return v, nil
}

// BuildGetPointChartPayload builds the payload for the Points GetPointChart
// endpoint from CLI flags.
func BuildGetPointChartPayload(pointsGetPointChartResortCode string, pointsGetPointChartYear string) (*points.GetPointChartPayload, error) {
	var err error
	var resortCode string
	{
		resortCode = pointsGetPointChartResortCode
		err = goa.MergeErrors(err, goa.ValidatePattern("resortCode", resortCode, "[a-z]{3}"))
		if err != nil {
			return nil, err
		}
	}
	var year int
	{
		var v int64
		v, err = strconv.ParseInt(pointsGetPointChartYear, 10, strconv.IntSize)
		year = int(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for year, must be INT")
		}
		if year < 1990 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("year", year, 1990, true))
		}
		if year > 2100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("year", year, 2100, false))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &points.GetPointChartPayload{}
	v.ResortCode = resortCode
	v.Year = year

	return v, nil
}

// BuildQueryStayPayload builds the payload for the Points QueryStay endpoint
// from CLI flags.
func BuildQueryStayPayload(pointsQueryStayFrom string, pointsQueryStayTo string, pointsQueryStayIncludeResorts string, pointsQueryStayExcludeResorts string, pointsQueryStayMinSleeps string, pointsQueryStayMaxSleeps string, pointsQueryStayMinBedrooms string, pointsQueryStayMaxBedrooms string, pointsQueryStayMinBeds string, pointsQueryStayMaxBeds string) (*points.Stay, error) {
	var err error
	var from string
	{
		from = pointsQueryStayFrom
		err = goa.MergeErrors(err, goa.ValidateFormat("from", from, goa.FormatDate))

		if err != nil {
			return nil, err
		}
	}
	var to string
	{
		to = pointsQueryStayTo
		err = goa.MergeErrors(err, goa.ValidateFormat("to", to, goa.FormatDate))

		if err != nil {
			return nil, err
		}
	}
	var includeResorts []string
	{
		if pointsQueryStayIncludeResorts != "" {
			err = json.Unmarshal([]byte(pointsQueryStayIncludeResorts), &includeResorts)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for includeResorts, \nerror: %s, \nexample of valid JSON:\n%s", err, "'[\n      \"blt\",\n      \"ssr\",\n      \"akv\"\n   ]'")
			}
			for _, e := range includeResorts {
				err = goa.MergeErrors(err, goa.ValidatePattern("includeResorts[*]", e, "[a-z]{3}"))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var excludeResorts []string
	{
		if pointsQueryStayExcludeResorts != "" {
			err = json.Unmarshal([]byte(pointsQueryStayExcludeResorts), &excludeResorts)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for excludeResorts, \nerror: %s, \nexample of valid JSON:\n%s", err, "'[\n      \"blt\",\n      \"ssr\",\n      \"akv\"\n   ]'")
			}
			for _, e := range excludeResorts {
				err = goa.MergeErrors(err, goa.ValidatePattern("excludeResorts[*]", e, "[a-z]{3}"))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var minSleeps int
	{
		if pointsQueryStayMinSleeps != "" {
			var v int64
			v, err = strconv.ParseInt(pointsQueryStayMinSleeps, 10, strconv.IntSize)
			minSleeps = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for minSleeps, must be INT")
			}
			if minSleeps < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("minSleeps", minSleeps, 1, true))
			}
			if minSleeps > 12 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("minSleeps", minSleeps, 12, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var maxSleeps int
	{
		if pointsQueryStayMaxSleeps != "" {
			var v int64
			v, err = strconv.ParseInt(pointsQueryStayMaxSleeps, 10, strconv.IntSize)
			maxSleeps = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for maxSleeps, must be INT")
			}
			if maxSleeps < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("maxSleeps", maxSleeps, 1, true))
			}
			if maxSleeps > 12 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("maxSleeps", maxSleeps, 12, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var minBedrooms int
	{
		if pointsQueryStayMinBedrooms != "" {
			var v int64
			v, err = strconv.ParseInt(pointsQueryStayMinBedrooms, 10, strconv.IntSize)
			minBedrooms = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for minBedrooms, must be INT")
			}
			if minBedrooms < 0 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("minBedrooms", minBedrooms, 0, true))
			}
			if minBedrooms > 3 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("minBedrooms", minBedrooms, 3, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var maxBedrooms int
	{
		if pointsQueryStayMaxBedrooms != "" {
			var v int64
			v, err = strconv.ParseInt(pointsQueryStayMaxBedrooms, 10, strconv.IntSize)
			maxBedrooms = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for maxBedrooms, must be INT")
			}
			if maxBedrooms < 0 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("maxBedrooms", maxBedrooms, 0, true))
			}
			if maxBedrooms > 3 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("maxBedrooms", maxBedrooms, 3, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var minBeds int
	{
		if pointsQueryStayMinBeds != "" {
			var v int64
			v, err = strconv.ParseInt(pointsQueryStayMinBeds, 10, strconv.IntSize)
			minBeds = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for minBeds, must be INT")
			}
			if minBeds < 2 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("minBeds", minBeds, 2, true))
			}
			if minBeds > 6 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("minBeds", minBeds, 6, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var maxBeds int
	{
		if pointsQueryStayMaxBeds != "" {
			var v int64
			v, err = strconv.ParseInt(pointsQueryStayMaxBeds, 10, strconv.IntSize)
			maxBeds = int(v)
			if err != nil {
				return nil, fmt.Errorf("invalid value for maxBeds, must be INT")
			}
			if maxBeds < 2 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("maxBeds", maxBeds, 2, true))
			}
			if maxBeds > 6 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("maxBeds", maxBeds, 6, false))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	v := &points.Stay{}
	v.From = from
	v.To = to
	v.IncludeResorts = includeResorts
	v.ExcludeResorts = excludeResorts
	v.MinSleeps = minSleeps
	v.MaxSleeps = maxSleeps
	v.MinBedrooms = minBedrooms
	v.MaxBedrooms = maxBedrooms
	v.MinBeds = minBeds
	v.MaxBeds = maxBeds

	return v, nil
}
